name: Code Analysis

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]

jobs:
  code-quality:
    name: Code Quality Checks
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flake8 mypy pyflakes

    - name: Check for legacy imports
      run: |
        echo "Checking for imports from legacy folder..."
        ERRORS=0

        # Find Python files outside of legacy folder that import from legacy
        for file in $(find . -name "*.py" -not -path "./legacy/*" -not -path "./.venv/*" -not -path "./venv/*"); do
          # Check for direct imports from legacy folder
          if grep -n "from legacy" "$file" 2>/dev/null; then
            echo "ERROR: $file imports from legacy folder"
            ERRORS=$((ERRORS + 1))
          fi

          # Check for imports of legacy modules that were moved
          if grep -n "^from gasto_tasks import\|^import gasto_tasks" "$file" 2>/dev/null; then
            echo "ERROR: $file imports from gasto_tasks (moved to legacy folder)"
            ERRORS=$((ERRORS + 1))
          fi

          if grep -n "^from mapp_partidas_cuenta_example import\|^import mapp_partidas_cuenta_example" "$file" 2>/dev/null; then
            echo "ERROR: $file imports from mapp_partidas_cuenta_example (moved to legacy folder)"
            ERRORS=$((ERRORS + 1))
          fi
        done

        if [ $ERRORS -gt 0 ]; then
          echo ""
          echo "Found $ERRORS legacy import errors!"
          echo "Please update imports to use new modules (e.g., sical_base instead of gasto_tasks)"
          exit 1
        fi

        echo "No legacy imports found"

    - name: Python Syntax Check
      run: |
        echo "Checking Python syntax..."
        python -m py_compile $(find . -name "*.py" -not -path "./legacy/*" -not -path "./.venv/*" -not -path "./venv/*")
        echo "All Python files have valid syntax"

    - name: Check for import errors with pyflakes
      run: |
        echo "Checking for undefined imports and unused imports..."
        # Check only non-legacy Python files
        find . -name "*.py" -not -path "./legacy/*" -not -path "./.venv/*" -not -path "./venv/*" -exec pyflakes {} \;
        echo "Import analysis complete"

    - name: Flake8 Linting (warnings only)
      continue-on-error: true
      run: |
        echo "Running flake8 for code style issues..."
        flake8 . --exclude=legacy,venv,.venv --count --select=E9,F63,F7,F82 --show-source --statistics
        echo "Flake8 check complete"

    - name: Check module imports are resolvable
      run: |
        echo "Verifying module imports are resolvable..."
        ERRORS=0

        # Create a script to check imports
        cat > /tmp/check_imports.py << 'EOF'
        import ast
        import sys
        from pathlib import Path

        def check_imports(file_path):
            errors = []
            try:
                with open(file_path, 'r') as f:
                    tree = ast.parse(f.read())

                for node in ast.walk(tree):
                    if isinstance(node, ast.Import):
                        for alias in node.names:
                            # Check if importing from legacy modules
                            if alias.name in ['gasto_tasks', 'mapp_partidas_cuenta_example']:
                                errors.append(f"Line {node.lineno}: import {alias.name} (legacy module)")
                    elif isinstance(node, ast.ImportFrom):
                        if node.module in ['gasto_tasks', 'mapp_partidas_cuenta_example']:
                            errors.append(f"Line {node.lineno}: from {node.module} import ... (legacy module)")
                        elif node.module and node.module.startswith('legacy'):
                            errors.append(f"Line {node.lineno}: from {node.module} import ... (legacy folder)")
            except SyntaxError as e:
                errors.append(f"Syntax error: {e}")

            return errors

        if __name__ == "__main__":
            file_path = sys.argv[1]
            errors = check_imports(file_path)
            for error in errors:
                print(f"  {error}")
            sys.exit(len(errors))
        EOF

        for file in $(find . -name "*.py" -not -path "./legacy/*" -not -path "./.venv/*" -not -path "./venv/*"); do
          result=$(python /tmp/check_imports.py "$file" 2>&1)
          if [ $? -ne 0 ]; then
            echo "ERROR in $file:"
            echo "$result"
            ERRORS=$((ERRORS + 1))
          fi
        done

        if [ $ERRORS -gt 0 ]; then
          echo ""
          echo "Found import issues in $ERRORS file(s)!"
          exit 1
        fi

        echo "All imports are valid"

  dependency-check:
    name: Check Dependencies
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Verify requirements.txt exists
      run: |
        if [ -f requirements.txt ]; then
          echo "requirements.txt found"
          cat requirements.txt
        else
          echo "WARNING: requirements.txt not found"
        fi

    - name: Check for circular imports
      run: |
        echo "Checking for potential circular imports..."
        # Simple check - look for files that import each other
        python << 'EOF'
        import ast
        from pathlib import Path
        from collections import defaultdict

        def get_imports(file_path):
            imports = set()
            try:
                with open(file_path, 'r') as f:
                    tree = ast.parse(f.read())
                for node in ast.walk(tree):
                    if isinstance(node, ast.Import):
                        for alias in node.names:
                            imports.add(alias.name.split('.')[0])
                    elif isinstance(node, ast.ImportFrom):
                        if node.module:
                            imports.add(node.module.split('.')[0])
            except:
                pass
            return imports

        # Build import graph
        import_graph = defaultdict(set)
        py_files = list(Path('.').glob('**/*.py'))
        py_files = [f for f in py_files if 'legacy' not in str(f) and 'venv' not in str(f)]

        for py_file in py_files:
            module_name = py_file.stem
            imports = get_imports(py_file)
            import_graph[module_name] = imports

        # Check for direct circular imports
        for module, imports in import_graph.items():
            for imp in imports:
                if imp in import_graph and module in import_graph[imp]:
                    print(f"WARNING: Potential circular import between {module} and {imp}")

        print("Circular import check complete")
        EOF
